-- Create PvP Matches Table for persistence and state recovery
CREATE TABLE IF NOT EXISTS public.pvp_matches (
    id TEXT PRIMARY KEY,
    -- Match ID generated by matchmaking
    attacker_id TEXT,
    -- Can be User UUID or Guest Session ID
    defender_id TEXT,
    attacker_hp INTEGER DEFAULT 100,
    defender_hp INTEGER DEFAULT 100,
    attacker_stats JSONB DEFAULT '{}'::jsonb,
    defender_stats JSONB DEFAULT '{}'::jsonb,
    turn_player_id TEXT,
    status TEXT DEFAULT 'ACTIVE',
    -- ACTIVE, FINISHED, ERROR
    winner_id TEXT,
    last_update TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Enable RLS
ALTER TABLE public.pvp_matches ENABLE ROW LEVEL SECURITY;
-- Policy: Everyone can read matches (needed for recovery/handshake)
CREATE POLICY "Public Read Matches" ON public.pvp_matches FOR
SELECT USING (true);
-- Policy: Service Role can update everything (Backend Authority)
CREATE POLICY "Service Role Update" ON public.pvp_matches USING (auth.role() = 'service_role') WITH CHECK (auth.role() = 'service_role');
-- Policy: Authenticated users can update matches they are part of (Ephemeral Broadcast Fallback)
-- Note: In a fully authoritative model, only the backend would update this. 
-- For the current hybrid approach, we allow participants to persist their state.
CREATE POLICY "Participants Update" ON public.pvp_matches FOR
UPDATE USING (true) -- Simplified for development, ideally check participant IDs
    WITH CHECK (true);